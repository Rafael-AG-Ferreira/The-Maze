{
  "version": 3,
  "sources": ["../cannon-es-debugger/dist/cannon-es-debugger.js", "dep:cannon-es-debugger"],
  "sourcesContent": ["import { Vec3, Quaternion, Shape } from 'cannon-es';\nimport { MeshBasicMaterial, SphereGeometry, BoxGeometry, PlaneGeometry, Mesh, CylinderGeometry, BufferGeometry, Float32BufferAttribute } from 'three';\n\nfunction CannonDebugger(scene, world, _temp) {\n  let {\n    color = 0x00ff00,\n    scale = 1,\n    onInit,\n    onUpdate\n  } = _temp === void 0 ? {} : _temp;\n  const _meshes = [];\n\n  const _material = new MeshBasicMaterial({\n    color: color != null ? color : 0x00ff00,\n    wireframe: true\n  });\n\n  const _tempVec0 = new Vec3();\n\n  const _tempVec1 = new Vec3();\n\n  const _tempVec2 = new Vec3();\n\n  const _tempQuat0 = new Quaternion();\n\n  const _sphereGeometry = new SphereGeometry(1);\n\n  const _boxGeometry = new BoxGeometry(1, 1, 1);\n\n  const _planeGeometry = new PlaneGeometry(10, 10, 10, 10); // Move the planeGeometry forward a little bit to prevent z-fighting\n\n\n  _planeGeometry.translate(0, 0, 0.0001);\n\n  function createConvexPolyhedronGeometry(shape) {\n    const geometry = new BufferGeometry(); // Add vertices\n\n    const positions = [];\n\n    for (let i = 0; i < shape.vertices.length; i++) {\n      const vertex = shape.vertices[i];\n      positions.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3)); // Add faces\n\n    const indices = [];\n\n    for (let i = 0; i < shape.faces.length; i++) {\n      const face = shape.faces[i];\n      const a = face[0];\n\n      for (let j = 1; j < face.length - 1; j++) {\n        const b = face[j];\n        const c = face[j + 1];\n        indices.push(a, b, c);\n      }\n    }\n\n    geometry.setIndex(indices);\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n\n  function createTrimeshGeometry(shape) {\n    const geometry = new BufferGeometry();\n    const positions = [];\n    const v0 = _tempVec0;\n    const v1 = _tempVec1;\n    const v2 = _tempVec2;\n\n    for (let i = 0; i < shape.indices.length / 3; i++) {\n      shape.getTriangleVertices(i, v0, v1, v2);\n      positions.push(v0.x, v0.y, v0.z);\n      positions.push(v1.x, v1.y, v1.z);\n      positions.push(v2.x, v2.y, v2.z);\n    }\n\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n\n  function createHeightfieldGeometry(shape) {\n    const geometry = new BufferGeometry();\n    const s = shape.elementSize || 1; // assumes square heightfield, else i*x, j*y\n\n    const positions = shape.data.flatMap((row, i) => row.flatMap((z, j) => [i * s, j * s, z]));\n    const indices = [];\n\n    for (let xi = 0; xi < shape.data.length - 1; xi++) {\n      for (let yi = 0; yi < shape.data[xi].length - 1; yi++) {\n        const stride = shape.data[xi].length;\n        const index = xi * stride + yi;\n        indices.push(index + 1, index + stride, index + stride + 1);\n        indices.push(index + stride, index + 1, index);\n      }\n    }\n\n    geometry.setIndex(indices);\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n\n  function createMesh(shape) {\n    let mesh = new Mesh();\n    const {\n      SPHERE,\n      BOX,\n      PLANE,\n      CYLINDER,\n      CONVEXPOLYHEDRON,\n      TRIMESH,\n      HEIGHTFIELD\n    } = Shape.types;\n\n    switch (shape.type) {\n      case SPHERE:\n        {\n          mesh = new Mesh(_sphereGeometry, _material);\n          break;\n        }\n\n      case BOX:\n        {\n          mesh = new Mesh(_boxGeometry, _material);\n          break;\n        }\n\n      case PLANE:\n        {\n          mesh = new Mesh(_planeGeometry, _material);\n          break;\n        }\n\n      case CYLINDER:\n        {\n          const geometry = new CylinderGeometry(shape.radiusTop, shape.radiusBottom, shape.height, shape.numSegments);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n\n      case CONVEXPOLYHEDRON:\n        {\n          const geometry = createConvexPolyhedronGeometry(shape);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n\n      case TRIMESH:\n        {\n          const geometry = createTrimeshGeometry(shape);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n\n      case HEIGHTFIELD:\n        {\n          const geometry = createHeightfieldGeometry(shape);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n    }\n\n    scene.add(mesh);\n    return mesh;\n  }\n\n  function scaleMesh(mesh, shape) {\n    const {\n      SPHERE,\n      BOX,\n      PLANE,\n      CYLINDER,\n      CONVEXPOLYHEDRON,\n      TRIMESH,\n      HEIGHTFIELD\n    } = Shape.types;\n\n    switch (shape.type) {\n      case SPHERE:\n        {\n          const {\n            radius\n          } = shape;\n          mesh.scale.set(radius * scale, radius * scale, radius * scale);\n          break;\n        }\n\n      case BOX:\n        {\n          mesh.scale.copy(shape.halfExtents);\n          mesh.scale.multiplyScalar(2 * scale);\n          break;\n        }\n\n      case PLANE:\n        {\n          break;\n        }\n\n      case CYLINDER:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n\n      case CONVEXPOLYHEDRON:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n\n      case TRIMESH:\n        {\n          mesh.scale.copy(shape.scale).multiplyScalar(scale);\n          break;\n        }\n\n      case HEIGHTFIELD:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n    }\n  }\n\n  function typeMatch(mesh, shape) {\n    if (!mesh) return false;\n    const {\n      geometry\n    } = mesh;\n    return geometry instanceof SphereGeometry && shape.type === Shape.types.SPHERE || geometry instanceof BoxGeometry && shape.type === Shape.types.BOX || geometry instanceof PlaneGeometry && shape.type === Shape.types.PLANE || geometry.id === shape.geometryId && shape.type === Shape.types.CYLINDER || geometry.id === shape.geometryId && shape.type === Shape.types.CONVEXPOLYHEDRON || geometry.id === shape.geometryId && shape.type === Shape.types.TRIMESH || geometry.id === shape.geometryId && shape.type === Shape.types.HEIGHTFIELD;\n  }\n\n  function updateMesh(index, shape) {\n    let mesh = _meshes[index];\n    let didCreateNewMesh = false;\n\n    if (!typeMatch(mesh, shape)) {\n      if (mesh) scene.remove(mesh);\n      _meshes[index] = mesh = createMesh(shape);\n      didCreateNewMesh = true;\n    }\n\n    scaleMesh(mesh, shape);\n    return didCreateNewMesh;\n  }\n\n  function update() {\n    const meshes = _meshes;\n    const shapeWorldPosition = _tempVec0;\n    const shapeWorldQuaternion = _tempQuat0;\n    let meshIndex = 0;\n\n    for (const body of world.bodies) {\n      for (let i = 0; i !== body.shapes.length; i++) {\n        const shape = body.shapes[i];\n        const didCreateNewMesh = updateMesh(meshIndex, shape);\n        const mesh = meshes[meshIndex];\n\n        if (mesh) {\n          // Get world position\n          body.quaternion.vmult(body.shapeOffsets[i], shapeWorldPosition);\n          body.position.vadd(shapeWorldPosition, shapeWorldPosition); // Get world quaternion\n\n          body.quaternion.mult(body.shapeOrientations[i], shapeWorldQuaternion); // Copy to meshes\n\n          mesh.position.copy(shapeWorldPosition);\n          mesh.quaternion.copy(shapeWorldQuaternion);\n          if (didCreateNewMesh && onInit instanceof Function) onInit(body, mesh, shape);\n          if (!didCreateNewMesh && onUpdate instanceof Function) onUpdate(body, mesh, shape);\n        }\n\n        meshIndex++;\n      }\n    }\n\n    for (let i = meshIndex; i < meshes.length; i++) {\n      const mesh = meshes[i];\n      if (mesh) scene.remove(mesh);\n    }\n\n    meshes.length = meshIndex;\n  }\n\n  return {\n    update\n  };\n}\n\nexport { CannonDebugger as default };\n", "import d from \"./node_modules/cannon-es-debugger/dist/cannon-es-debugger.js\";export default d;"],
  "mappings": "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",
  "names": []
}
